---
layout:     post
title:      JVM知识点
subtitle:   
date:       2019-2-26
author:     BY KiloMeter
header-img: img/2019-2-26-JVM知识点/28.jpg
catalog: true
tags:
    - JVM
---

### Java内存模型

![](/img/2019-2-26-JVM知识点/Java内存模型.png)

### JVM内存区域

JVM内存区域主要分为线程共享部分(堆、方法区，也称为永久代)、线程私有部分(PC寄存器、本地方法栈、虚拟机栈，也称为方法栈)、直接内存。

### JVM各内存区域的作用

#### 堆

该区域存放着所有的对象实例和数组，是GC的主要处理区域。由于JVM使用分代收集算法，因此从GC的角度可以细分为新生代(Eden区、From Survivor区和To Survivor区)和老年代。

#### 方法区(永久代)

存储类信息、常量、静态变量、即时编译器编译后的代码(常量池就是在这里，在Java8之后，常量池移动到了堆内存中，方法区的内容不再放入JVM，而是放入本地内存)。VM在这里使用了和堆一样的垃圾回收算法，这样的话虚拟机就可以像管理堆内存一样管理方法区的内存，而不必要为方法区开发专门的内存管理器(永久带的内存回收的主要目标是针对常量池的回收和类型的卸载, 因此收益一般很小)。

#### PC寄存器

指向虚拟机字节码指令的位置。

#### 本地方法栈

为虚拟机使用到的Native 方法服务。如Java使用c或者c++编写的接口服务时，代码在此区运行。但是在HotSpot VM(目前最流行的虚拟机)直接把本地方栈和虚拟机栈合二为一。

#### 虚拟机栈 

也称为方法栈，该区域描述的是Java方法执行时的内存模型，每个方法在执行的同时会创建一个**栈帧**，用于存储局部变量表，操作数栈，动态链接，方法出口等信息。每一个方法从调用到结束的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。

线程私有数据区域生命周期与线程相同, 依赖用户线程的启动/结束 而 创建/销毁(在 HotspotVM 内, 每个线程都与操作系统的本地线程直接映射, 因此这部分内存区域的存/否跟随本地线程的生/死对应)。 

线程共享区域随虚拟机的启动/关闭而创建/销毁。 

因为线程私有的区域会随着线程的终结而进行回收，空间比较容易清理，而线程共享的部分空间较大，很容易产生垃圾信息，因此大部分人关注的、与对象内存分配关系最密切的内存区域是**堆**和**方法区**。

### Java运行时内存

Java 堆从 GC 的角度还可以细分为: **新生代(Eden 区、 From Survivor 区和 To Survivor 区)和老年
代**。 

![](/img/2019-2-26-JVM知识点/堆结构.png)

#### 新生代

是用来存放新生的对象。一般占据堆的 1/3 空间。由于频繁创建对象，所以新生代会频繁触发MinorGC 进行垃圾回收。新生代又分为 Eden 区、 Survivor From、 Survivor To 三个区。 

##### Eden区

Java 新对象的出生地（如果新创建的对象占用内存很大，则直接分配到老年代）。当 Eden 区内存不够的时候就会触发 MinorGC，对新生代区进行一次垃圾回收。 

##### Survivor From

上一次 GC 的幸存者，作为这一次 GC 的被扫描者。 

##### Survivor To

保留了一次 MinorGC 过程中的幸存者。  

#####  <span id = "MinorGC"> MinorGC 的过程（复制->清空->互换）</span>

MinorGC采用**复制算法**。步骤如下：

1、eden、Survivor From 复制到Survivor To，年龄+1(默认情况下年龄到达 15 的对象会被移到老生代中。)

首先，把 Eden 和 ServivorFrom 区域中存活的对象复制到 ServicorTo 区域（如果有对象的年龄以及达到了老年的标准，则赋值到老年代区），同时把这些对象的年龄+1（如果 ServicorTo 不够位置了就放到老年区）； 

2、清空eden和Survivor From的对象

3、最后， Survivor To 和 Survivor From 互换，原 Survivor To 成为下一次 GC 时的 Survivor From区 

#### 老年代

主要存放应用程序中生命周期长的内存对象。

因为老年代中的对象比较稳定，因此很少会触发MajorGC，一般触发Major GC(full GC)之前都会先触发以下MinorGC，使得新生代的对象晋入到老年代后，导致空间不够时触发，上面说到新创建的较大对象会直接放到老年代，因此如果老年代没有足够的空间存放新创建的对象时也会触发MajorGC，为新对象腾出内存空间

##### MajorGC的过程

MajorGC采用**标记清除算法**。步骤如下：

首先扫描一次所有老年代，标记出存活的对象，然后回收没有标记的对象。 MajorGC 的耗时比较长，因为要扫描再回收。 MajorGC 会产生内存碎片，为了减少内存损耗，我们一般需要进行合并或者标记出来方便下次直接分配。当老年代也满了装不下的时候，就会抛出 OOM（Out of Memory）异常。 

#### 永久代

指的是内存的永久保存区域，主要存放Class和Meta(元数据)的信息，Class在被加载的时候被放入永久代区域，它和存放实例的区域不同,**GC 不会在主程序运行期对永久区域进行清理**。所以这也导致了永久代的区域会随着加载的 Class 的增多而胀满，最终抛出 OOM 异常。 

##### Java8、永久代与元数据

在 Java8 中， 永久代已经被移除，被一个称为“元数据区”（元空间）的区域所取代。元空间的本质和永久代类似，元空间与永久代之间最大的区别在于： 元空间并不在虚拟机中，而是使用本地内存。因此，默认情况下，元空间的大小仅受本地内存限制。 类的元数据放入 native memory, 字符串池和类的静态变量放入 java 堆中， 这样可以加载多少类的元数据就不再由MaxPermSize 控制, 而由系统的实际可用空间来控制。 

### 垃圾回收与垃圾回收算法

#### 如何确定垃圾

##### 引用计数法

在 Java 中，引用和对象是有关联的。如果要操作对象则必须用引用进行。因此，很显然一个简单的办法是通过引用计数来判断一个对象是否可以回收。简单说，即一个对象如果没有任何与之关联的引用， 即他们的引用计数都不为 0， 则说明对象不太可能再被用到，那么这个对象就是可回收对象。

##### 引用计数法存在的问题

但是Java并不采用引用计数法，原因如下：

jdk从1.2开始增加了多种引用方式：软引用、弱引用、虚引用，且在不同引用情况下程序应进行不同的操作。如果我们只采用一个引用计数法来计数无法准确的区分这么多种引用的情况。

上面这个原因并不是致命的，因为可以通过增加逻辑区分这几种情况，让引用计数法真正无法使用的是下面的原因。

 如果一个对象A持有对象B，而对象B也持有一个对象A，那发生了类似操作系统中死锁的循环持有，这种情况下A与B的counter恒大于1，会使得GC永远无法回收这两个对象。这个就是循环引用问题。

##### 可达性分析

为了解决此循环引用问题，Java 使用了可达性分析的方法。通过一系列的“GC roots”对象作为起点搜索。如果在“GC roots”和一个对象之间没有可达路径，则称该对象是不可达的。 要注意的是，不可达对象不等价于可回收对象， 不可达对象变为可回收对象**至少要经过两次标记过程**。两次标记后仍然是可回收对象，则将面临回收。 

什么对象可以作为GC roots呢？

- 虚拟机栈（栈帧中的本地变量表）中引用的对象；
- 方法区中类静态属性引用的对象；
- 方法区中常量引用的对象；
- 本地方法栈中JNI（即一般说的Native方法）引用的对象；

总结就是，方法运行时，方法中引用的对象；类的静态变量引用的对象；类中常量引用的对象；Native方法中引用的对象。

#### 垃圾回收算法

##### 标记清除法（Mark-Sweep） 

最基础的垃圾回收算法，分为两个阶段，标注和清除。标记阶段标记出所有需要回收的对象，清除阶段回收被标记的对象所占用的空间。如图 

![](/img/2019-2-26-JVM知识点/标记清除算法.png)

从图中我们就可以发现，该算法最大的问题是内存碎片化严重，后续可能发生大对象不能找到可利用空间的问题。

##### <span id="copy">复制算法（copying）  </span>

为了解决 Mark-Sweep 算法内存碎片化的缺陷而被提出的算法。按内存容量将内存划分为等大小的两块。每次只使用其中一块，当这一块内存满后将尚存活的对象复制到另一块上去，把已使用的内存清掉，如图： 

![](/img/2019-2-26-JVM知识点/复制算法.png)

这种算法虽然实现简单，内存效率高，不易产生碎片，但是最大的问题是可用内存被压缩到了原本的一半。且存活对象增多的话， Copying 算法的效率会大大降低。 

##### <span id="Mark-Compact">标记整理算法(Mark-Compact) </span>

结合了以上两个算法，为了避免缺陷而提出。标记阶段和 Mark-Sweep 算法相同， 标记后不是清理对象，而是将存活对象移向内存的一端。然后清除端边界外的对象。如图： 

![](/img/2019-2-26-JVM知识点/标记整理算法.png)

##### 分代收集算法

分代收集法是目前大部分 JVM 所采用的方法，其核心思想是根据对象存活的不同生命周期将内存划分为不同的域，一般情况下将 GC 堆划分为老生代(Tenured/Old Generation)和新生代(Young Generation)。老生代的特点是每次垃圾回收时只有少量对象需要被回收，新生代的特点是每次垃圾回收时都有大量垃圾需要被回收，因此可以**根据不同区域选择不同的算法**。 

根据 [MinorGC 的过程(复制->清空->互换)](#MinorGC)可以知道新生代采用的是[复制算法](#copy)。因为新生代中每次垃圾回收都要回收大部分对象，即要复制的操作比较少，但通常并不是按照 1： 1 来划分新生代。一般将新生代划分为一块较大的 Eden 空间和两个较小的 Survivor 空间(From Space, To Space)，每次使用Eden 空间和其中的一块 Survivor To空间，当进行回收时，将该两块空间中还存活的对象复制到另一块 Survivor From空间中 

因为老年代每次只回收少量对象，所以老年代使用的是[标记整理算法(Mark-Compact) ](#Mark-Compact) 

### Java的四种引用

#### 强引用 

在 Java 中最常见的就是强引用， 把一个对象赋给一个引用变量，这个引用变量就是一个强引用。当一个对象被强引用变量引用时，它处于可达状态，它是不可能被垃圾回收机制回收的，即使该对象以后永远都不会被用到 JVM也不会回收。因此强引用是造成 Java 内存泄漏的主要原因之一。 

#### 软引用 

软引用需要用 SoftReference 类来实现，对于只有软引用的对象来说，当系统内存足够时它不会被回收，当系统内存空间不足时它会被回收。软引用通常用在对内存敏感的程序中。 

#### 弱引用

弱引用需要用 WeakReference 类来实现，它比软引用的生存期更短，对于只有弱引用的对象来说，只要垃圾回收机制一运行，不管 JVM 的内存空间是否足够，总会回收该对象占用的内存。 

#### 虚引用

虚引用需要 PhantomReference 类来实现，它不能单独使用，必须和引用队列联合使用。 虚引用的主要作用是跟踪对象被垃圾回收的状态。 

### GC垃圾收集器

#### Serial 垃圾收集器（单线程、 复制算法） 

Serial（英文连续） 是最基本垃圾收集器，使用复制算法，曾经是JDK1.3.1 之前新生代唯一的垃圾收集器。 Serial 是一个单线程的收集器，它不但只会使用一个 CPU 或一条线程去完成垃圾收集工作，并且在进行垃圾收集的同时，必须暂停其他所有的工作线程，直到垃圾收集结束。

Serial 垃圾收集器虽然在收集垃圾过程中需要暂停所有其他的工作线程，但是它简单高效，对于限定单个 CPU 环境来说，没有线程交互的开销，可以获得最高的单线程垃圾收集效率，因此 Serial垃圾收集器依然是 java 虚拟机运行在 Client 模式下默认的新生代垃圾收集器。 

#### ParNew 垃圾收集器（Serial+多线程） 

ParNew 垃圾收集器其实是 Serial 收集器的多线程版本，也使用复制算法，除了使用多线程进行垃圾收集之外，其余的行为和 Serial 收集器完全一样， ParNew 垃圾收集器在垃圾收集过程中同样也要暂停所有其他的工作线程 。

ParNew 收集器默认开启和 CPU 数目相同的线程数，可以通过-XX:ParallelGCThreads 参数来限制垃圾收集器的线程数。 【Parallel：平行的】
ParNew 虽然是除了多线程外和Serial 收集器几乎完全一样，但是ParNew垃圾收集器是很多 java虚拟机运行在 Server 模式下新生代的默认垃圾收集器。 

#### Parallel Scavenge 收集器（多线程复制算法、高效） 

Parallel Scavenge 收集器也是一个新生代垃圾收集器，同样使用复制算法，也是一个多线程的垃圾收集器， 它重点关注的是程序达到一个可控制的吞吐量（Thoughput， CPU 用于运行用户代码的时间/CPU 总消耗时间，即吞吐量=运行用户代码时间/(运行用户代码时间+垃圾收集时间)），高吞吐量可以最高效率地利用 CPU 时间，尽快地完成程序的运算任务，主要适用于在后台运算而不需要太多交互的任务。 **自适应调节策略也是 ParallelScavenge 收集器与 ParNew 收集器的一个重要区别**。 

#### Serial Old 收集器（单线程标记整理算法 ） 

Serial Old 是 Serial 垃圾收集器年老代版本，它同样是个单线程的收集器，使用标记-整理算法，这个收集器也主要是运行在 Client 默认的 java 虚拟机默认的年老代垃圾收集器。在 Server 模式下，主要有两个用途：
1. 在 JDK1.5 之前版本中与新生代的 Parallel Scavenge 收集器搭配使用。
2. 作为年老代中使用 CMS 收集器的后备垃圾收集方案。
  新生代 Serial 与年老代 Serial Old 搭配垃圾收集过程图： 

![](/img/2019-2-26-JVM知识点/新生代serial和老年代serial old搭配使用.png)

新生代 Parallel Scavenge 收集器与 ParNew 收集器工作原理类似，都是多线程的收集器，都使用的是复制算法，在垃圾收集过程中都需要暂停所有的工作线程。新生代 Parallel Scavenge/ParNew 与年老代 Serial Old 搭配垃圾收集过程图： 

![](/img/2019-2-26-JVM知识点/新生代 Parallel 和老年代serial old 搭配使用.png)

#### Parallel Old 收集器（多线程标记整理算法） 

Parallel Old 收集器是Parallel Scavenge的年老代版本，使用多线程的标记-整理算法，在 JDK1.6才开始提供。

在 JDK1.6 之前，新生代使用 ParallelScavenge 收集器只能搭配年老代的 Serial Old 收集器，只能保证新生代的吞吐量优先，无法保证整体的吞吐量， Parallel Old 正是为了在年老代同样提供吞吐量优先的垃圾收集器， 如果系统对吞吐量要求比较高，可以优先考虑新生代 Parallel Scavenge和年老代 Parallel Old 收集器的搭配策略。

新生代 Parallel Scavenge 和年老代 Parallel Old 收集器搭配运行过程图： 

![](/img/2019-2-26-JVM知识点/新生代 Parallel Scavenge 和年老代 Parallel Old 收集器搭配.png)

#### CMS 收集器（多线程标记清除算法） 

Concurrent mark sweep(CMS)收集器是一种年老代垃圾收集器，其最主要目标是获取最短垃圾回收停顿时间， 和其他年老代使用标记-整理算法不同，它使用多线程的标记-清除算法。

最短的垃圾收集停顿时间可以为交互比较高的程序提高用户体验。CMS 工作机制相比其他的垃圾收集器来说更复杂，整个过程分为以下 4 个阶段： 

1、**初始标记**：只是标记一下 GC Roots 能直接关联的对象，速度很快，仍然需要暂停所有的工作线程。 

2、**并发标记**：进行 GC Roots 跟踪的过程，和用户线程一起工作，不需要暂停工作线程。 

3、**重新标记**：为了修正在并发标记期间，因用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，仍然需要暂停所有的工作线程 

4、**并发清除**：清除 GC Roots 不可达对象，和用户线程一起工作，不需要暂停工作线程。由于耗时最长的并发标记和并发清除过程中，垃圾收集线程可以和用户现在一起并发工作， 所以总体上来看CMS 收集器的内存回收和用户线程是一起并发地执行。

CMS 收集器工作过程： 

![](/img/2019-2-26-JVM知识点/CMS 收集器工作过程.png)

#### G1 收集器 

Garbage first 垃圾收集器是目前垃圾收集器理论发展的最前沿成果，相比与 CMS 收集器， G1 收集器两个最突出的改进是：
1. 基于标记-整理算法，不产生内存碎片。

2. 可以非常精确控制停顿时间，在不牺牲吞吐量前提下，实现低停顿垃圾回收。

  G1 收集器避免全区域垃圾收集，它把堆内存划分为大小固定的几个独立区域，并且跟踪这些区域的垃圾收集进度，同时在后台维护一个优先级列表，每次根据所允许的收集时间， 优先回收垃圾最多的区域。区域划分和优先级区域回收机制，确保 G1 收集器可以在有限时间获得最高的垃圾收集效率。 

### JVM类加载机制

JVM的加载机制分为五个部分，分别是：加载，验证，准备，解析，初始化。

![](/img/2019-2-26-JVM知识点/JVM类加载过程.PNG)

#### 加载

加载是类加载过程中的一个阶段， 这个阶段会在内存中生成一个代表这个类的 java.lang.Class 对象， 作为方法区这个类的各种数据的入口。注意这里不一定非得要从一个 Class 文件获取，这里既可以从 ZIP 包中读取（比如从jar 包和 war 包中读取），也可以在运行时计算生成（动态代理），也可以由其它文件生成（比如将 JSP 文件转换成对应的 Class 类）。 在加载这个过程中，既可以使用系统提供的类加载器，也可以使用自定义的类加载器来完成加载。

#### 验证

这一阶段的主要目的是为了确保 Class 文件的字节流中包含的信息是否符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。 

#### 准备

准备阶段是正式为类变量分配内存并设置类变量的初始值阶段，即在方法区中分配这些变量所使用的内存空间。注意这里所说的初始值概念，比如一个类变量定义为： 

```java
public static int v = 8080;
```

实际上变量 v 在准备阶段过后的初始值为 0 而不是 8080， 将 v 赋值为 8080 的 public static 指令是程序被编译后， 存放于类构造器\<client\>方法之中

但是注意如果声明为： 

```java
public static final int v = 8080;
```

在编译阶段会为 v 生成 ConstantValue 属性，在准备阶段虚拟机会根据 ConstantValue 属性将 v赋值为 8080。 

#### 解析

解析阶段是指虚拟机将常量池中的**符号引用**替换为**直接引用**的过程。符号引用就是 class 文件中的： 

1、CONSTANT_Class_info

2、CONSTANT_Field_info

3、CONSTANT_Method_info

等类型的常量。

这里解释下什么是**符号引用**和**直接引用**

**符号引用：**符号引用与虚拟机实现的布局无关， 引用的目标并不一定要已经加载到内存中。 各种虚拟机实现的内存布局可以各不相同，但是它们能接受的符号引用必须是一致的，因为符号引用的字面量形式明确定义在 Java 虚拟机规范的 Class 文件格式中。 

**直接引用：** 直接引用可以是指向目标的指针，相对偏移量或是一个能间接定位到目标的句柄。如果有了直接引用，那引用的目标必定已经在内存中存在 。

#### 初始化

初始化阶段是类加载最后一个阶段，前面的类加载阶段之后，除了在加载阶段可以自定义类加载器以外，其它操作都由 JVM 主导。到了初始阶段，才开始真正执行类中定义的 Java 程序代码。 

初始化阶段是执行类构造器\<client\>方法的过程。 \<client\>方法是由编译器自动收集类中的类变量的赋值操作和静态语句块中的语句合并而成的。虚拟机会保证子\<client\>方法执行之前，父类的\<client\>方法已经执行完毕， 如果一个类中没有对静态变量赋值也没有静态语句块，那么编译器可以不为这个类生成\<client\>()方法。 

### 类加载器

在加载阶段虚拟机设计团队把加载动作放到 JVM 外部实现，以便让应用程序决定如何获取所需的类， JVM 提供了 3 种类加载器： 

**启动类加载器(Bootstrap ClassLoader)**：

负责加载 JAVA_HOME\lib 目录中的， 或通过-Xbootclasspath 参数指定路径中的， 且被虚拟机认可（按文件名识别， 如 rt.jar） 的类 

**扩展类加载器(Extension ClassLoader)**：

负责加载 JAVA_HOME\lib\ext 目录中的，或通过 java.ext.dirs 系统变量指定路径中的类库。 

**应用程序类加载器(Application ClassLoader):**

负责加载用户路径（classpath）上的类库。

JVM 通过双亲委派模型进行类的加载， 当然我们也可以通过继承 java.lang.ClassLoader实现自定义的类加载器。 

![](/img/2019-2-26-JVM知识点/双亲委派原则.PNG)

### 双亲委派原则

当一个类收到了类加载请求，他首先不会尝试自己去加载这个类，而是把这个请求委派给父类去完成，每一个层次类加载器都是如此，因此所有的加载请求都应该传送到启动类加载其中，只有当父类加载器反馈自己无法完成这个请求的时候（在它的加载路径下没有找到所需加载的Class）， 子类加载器才会尝试自己去加载。

采用双亲委派的一个好处是比如加载位于 rt.jar 包中的类 java.lang.Object，不管是哪个加载器加载这个类，最终都是委托给顶层的启动类加载器进行加载，这样就保证了使用不同的类加载器最终得到的都是同样一个 Object 对象。 
