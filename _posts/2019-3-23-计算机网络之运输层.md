---
layout:     post
title:      计算机网络之运输层
subtitle:   
date:       2019-3-23
author:     BY KiloMeter
header-img: img/2019-3-23-计算机网络之运输层/41.jpg
catalog: true
tags:
    - 计算机网络
---


运输层为不同主机上的应用进程之间提供了**逻辑通信**

运输层将从应用层传过来的报文转换层运输层**报文段**，实现方法是将应用报文划分成较小的块，并为每块加上一个运输层首部生成运输层报文段。

运输层协议有TCP和UDP，协议能够提供的服务受制于底层网络层协议的服务模型，假设如果网络层协议之间无法为主机提供时延或带宽保证的话，运输层协议也就无法为进程之间报文的传输提供保证。

网络层协议叫做IP，即网际协议，IP的服务模型是**尽力而为交付服务**，IP不保证报文段的交付，因此IP被称为**不可靠服务**

**多路分解和多路复用**

在一台主机中，可能同时有多个进程在接受网络数据，主机接受到的数据是如何传递到目标进程的呢？在发送数据的时候，一个进程有一个或多个套接字，因此在接受数据的时候，数据并不是直接有线程接收，而是先交付给套接字。一台主机上可能有多个套接字，套接字都有一个唯一的标识符，标识符的格式取决于它是UDP还是TCP套接字。在运输层检查报文段的字段，标识出接收套接字，进而将报文定向至该套接字，这个工作叫做**多路分解**，在传输层对数据装上首部信息，从而生成报文段，然后将报文段传递到网络层，这个过程叫做**多路复用**。

套接字上的唯一标识符就是**源端口号字段和目的端口号字段**，此外还有一些UDP和TCP的字段

通常Web服务器上只使用一个进程，但是为每个新的连接创建一个具有新连接套接字的新线程，如果使用持续HTTP，则一直使用同一个套接字，如果使用非持续HTTP，则每个请求会创建一个新的TCP连接并在随后关闭连接。

UDP相比于TCP的好处

1、TCP有拥塞控制机制，因此TCP不适合一些实时应用

2、无须建立连接，因此有更小的时延

3、无连接状态，因此可以支持更多的活跃用户

4、分组首部开销比较小，TCP报文段一般20字节，而UDP只有8字节

TCP和UDP的应用场景

TCP：HTTP，SMTP，Web传输，FTP

UDP：承载网络管理数据(SNMP)，因特网电话，视频会议

UDP首部报文都四个字段，分别是**源端口号、目的端口号、长度和校验和**

校验和是为了检测报文段在发送的过程中是否发生了改变。



rdt2.1和rdt2.2中ACK和NAK

在发送数据的过程中，如何确保数据的可靠性？

rdt2.1：

发送方发送数据，编号为0

接受方接受到数据后：

* 如果没有损坏，且编号为0，发送ACK，等待编号为1的数据
* 如果损坏，发送NAK，等待编号为0的数据

发送方接受到数据后：

* 如果没有损坏，且为ACK，无任何动作，等待上层调用
* 如果没有损坏，且为NAK，重新发送编号为0的数据
* 如果损坏，无论是NAK还是ACK，重新发送编号为0的数据

接受方接收到数据后：

* 如果没有损坏，且编号为1，则返回ACK，等待编号为0的数据(循环)
* 如果没有损坏，且编号为0，返回ACK，等待编号为1的数据
* 如果损坏，返回NAK，等待编号为0的数据

什么情况下会出现*分组冗余*？

发送方成功发送数据，接受方也成功接受数据，但是发送的ACK在路上损坏了，此时会导致发送方会重新发送编号为0的数据，而不是发送编号为1的数据。

rdt2.2的改变

发送方发送编号为0的数据

接受方接受到数据后：

* 如果没有损坏，返回ACK0，等待编号为1的数据
* 如果损坏，返回ACK1，继续等待编号为0的数据

发送方接受到数据后：

* 如果没有损坏，且为ACK0，无任何动作，等待上层调用
* 如果没有损坏，且为ACK1，重发编号为0的数据
* 如果损坏，重发编号为0的数据

接收方接受到数据后：

* 如果没有损坏，且编号为1，返回ACK1，等待编号为0的数据(循环)
* 如果没有损坏，且编号为0，返回ACK0，等待编号为1的数据
* 如果损坏，返回ACK1，等待编号为0的数据

**滑动窗口协议(GBN协议)**

又称为**回退N步协议**

GBN发送方必须响应的三种类型事件：

1、从上层接收分组。当上层调用rdt_send()时，首先检查发送窗口是否已满，即是否有N个已发送但未确认的分组，如果满了的话，要么将分组缓存，要么返回给上层。

2、收到一个ACK。对序号为n的分组的确认采用**累计确认**的方式，表明接收方已正确接收到序号n在内的以前所有分组。

3、超时事件，如果超时，发送方会重新发送**所有已发送但未确认的分组**，接受到ACK，但仍有已发送但未确认的分组，则计时器重新启动，如果没有已发送但未确认的分组，则停止计时器。

GBN接收方的动作：

如果接收到序号为n的分区，且上次交付的是序号为n-1的分组，则为分组n发送一个ACK。其他情况下**全都丢弃该分组**。

GBN协议的接收方在接收分组的时候，单个分组的差错会引起大量分组重传，因此出现了**SR(选择重传)协议**

选择重传协议也存在发送方和接收方，两方的事件和动作如下

发送方：

1、从上层接收分组的行为和GBN的一样

2、收到ACK。如果收到的ACK编号的分组在窗口内，SR将其该分组标记为已接收，如果接受的ACK编号的分组是在窗口的第一个，则会移动窗口的开始部分至具有最小序号的未确认分组处，后面部分在移动的过程中，将未发送分组进行发送

3、超时。在选择重传协议中，每个分组都有**自己的逻辑计时器**，超时后只能重新发送超时的分组。

接收方：

1、接收方方面需要处理的情况比GBN的复杂许多。首先，在接收方需要维护和发送方一样的滑动窗口，用于缓存已经接收到的数据。接受到数据后，检查接收分组的编号是否在窗口内，如果在窗口内且以前未收到过，则会缓存该分组，如果分组的编号在窗口的首部，则会**把从该分组开始，之后所有的已缓存分组交付给上层**，并移动窗口。在接受到数据后，会发送ACK+编号

2、如果序号的范围是 窗口的的最小编号-N(N为窗口的大小) 到 窗口的最小编号-1，则会产生一个ACK。

3、其他情况下忽略该分组。

为什么要有上面的第二步呢？

举个例子，假设发送方发送了编号为0的分组并且接受方成功接收到了，且编号1是接收方的窗口的第一个分组，那么接收方的窗口将会向前进行滑动，并且会向发送方发送一个ACK0，但是如果ACK0在发送的过程中丢失了，那么发送方无法接受到ACK0，也就是说，发送方的窗口将无法进行滑动，且由于接收方的窗口已经向前滑动了(已经滑动到了编号为1的分组处),将永远无法发出ACK0，因此发送方的窗口将**永远无法向前滑动**。
