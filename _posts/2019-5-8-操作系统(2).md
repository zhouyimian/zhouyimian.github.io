---
layout:     post
title:      操作系统(2)
subtitle:   
date:       2019-5-8
author:     BY KiloMeter
header-img: img/2019-5-8-操作系统(2)/50.png
catalog: true
tags:
    - 操作系统
---

## 线程的产生及概念

在计算机刚诞生的时候，各个程序之间只能是串行执行的，在引入和进程之后，通过中断可以实现多个进程“同时”执行，但是，在一个进程中，也是存在着“同时”做很多事情的情况，比如QQ，可能需要在发送文字的时候，同时发送文件，等等。因此这个时候就引入了线程，来增加并发度。

在线程出现之前，CPU服务的基本单元是进程，在引入线程之后，CPU服务的基本单元就变成了线程。因此，线程是CPU执行的基本单元。但是对于系统资源的分配仍是以进程为基本单元。

引入线程机制后的变化

![](/img/2019-5-8-操作系统(2)/引入线程机制后的变化.PNG)

线程的属性

![](/img/2019-5-8-操作系统(2)/线程的属性.png)

## 处理机调度

处理机调度是为了解决多个进程或线程争夺CPU的问题。在多道程序系统中，通常会有多个进程或线程同时竞争CPU，只要有两个及以上的进程或线程处于就绪状态就有可能出现这样的情况。当可用的CPU个数少于进程和线程数时，就必须选择下一个进入CPU的进程或线程，而这部分工作由处理机执行。处理机的调度分为高级调度、中级调度和低级调度。

### 高级调度(作业调度)

高级调度发生在作业对应的**新进程创建过程**中，CPU只能够执行处于内存中的进程，因此，如果一个作业要执行，首先得把该任务提交到内存中，但是由于内存有限，无法把所有的任务都提交到内存中，决定哪个任务先提交到内存创建对应的进程，这个就是高级调度需要解决的问题。高级调度是**外存和内存之间的调度**。注：**一个任务只会被调入一次，调出一次**

### 中级调度(内存调度)

当内存中的数目比较多时(由于虚拟内存的存在，可能会出现这种情况)，需要把一部分进程暂时从内存中移动到外存中，这样做的目的是为了提高**内存利用率和系统吞吐量**。暂时调到外存的进程是处于**挂起状态**。在该状态中，进程的**PCB还是保存在内存中**，被挂起进程的PCB会被放置在挂起队列。中级调度要解决的问题就是决定将哪个处于挂起队列的进程重新调入内存。注：**一个进程可能会被多次调入，多次调出**

下面先看下进程的五状态模型和七状态模型

![](/img/2019-5-8-操作系统(2)/进程的五状态模型.png)

五状态模型是最为常见的，有的时候也会使用下面的七状态模型

![](/img/2019-5-8-操作系统(2)/进程的七状态模型.png)

引入了就绪挂起和阻塞挂起状态

注：进程的挂起和阻塞，虽然都是处于不能获得CPU服务的状态，但是挂起的进程，其内存映像是在外存中的，阻塞的进程，其内存映像还在主存中。

### 低级调度(进程调度)

其主要任务是按照某种方法和策略从**就绪队列**中选取一个进程，将CPU分配给它

什么时候会发生进程调度与切换？

1、当前运行的进程**主动放弃**CPU(进程正常终止、运行过程发生异常而终止、进程主动请求阻塞，如等待IO)

2、当前运行的进程**被动放弃**CPU(分配给进程的时间片用完、由更紧急的事需要处理，如IO中断、有更高优先级的进程进入就绪队列)

不能发生进程调度与切换的情况

1、在处理中断的过程。由于中断的执行过程比较复杂，和硬件密切相关，很难在处理中断的过程中进行进程切换

2、进程在**操作系统内核程序临界区中**

3、在**原子操作中(就是前面说到的原语)**。原子操作不可中断，如修改PCB中的状态位，并把PCB放置到相应的队列中。如果该过程中发生了进程切换，两个操作分开操作了，那么PCB中的状态和进程所在的队列可能会出现不一致的情况，这样会对操作系统产生隐患。

#### 进程调度的方式

##### 非剥夺调度方式

只允许进程主动放弃CPU，即使有更紧急的任务到达，当前进程也会继续占有CPU，直到进程正常终止或主动要求进入阻塞态。这种方式实现简单，系统开销小但是无法及时处理紧急任务，适合于早期的批处理系统

##### 剥夺调度方式

当有更紧急的任务到达，会立即暂停现在正在执行的进程，让出CPU。这种方式可以优先处理更紧急的任务，也可以实现各进程按照**时间片轮流执行**的功能(通过时钟中断)。适用于分时操作系统、实时操作系统

![](/img/2019-5-8-操作系统(2)/三种调度的联系.png)

#### 进程调度算法

##### 先来先服务(FCFS)

##### 短作业优先(SJF)

短作业优先还分为抢占式和非抢占式

##### 高响应比优先

##### 时间片轮转算法

##### 优先级调度算法

##### 多级反馈队列调度算法

## 进程同步



## 进程互斥

## 死锁

### 死锁产生的四个条件

1、互斥条件：只有对必须互斥的资源进行争抢才会导致死锁

2、不剥夺条件：进程所获得的资源在使用完之前，不能被其他进程夺走

3、请求和保持条件：进程已经保持了至少一个资源，但又提出了新的资源请求

4、循环等待条件：存在一种进程资源的循环等待链。

### 死锁的处理策略

#### 1、预防死锁

**破坏死锁的四个必要条件中的其中一个**

#### 2、避免死锁

**用某种方法防止系统进入不安全状态，从而避免死锁(银行家算法)**

#### 3、死锁的检测和解除

**允许死锁发生，但由操作系统负责检测死锁的发生，然后采取某种措施解除死锁。**